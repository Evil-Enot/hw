# TFTP-сервер

Написан на Java.

## Запуск
1. Необходимо склинировать себе репозиторий, после чего через командную сторку скомпилировать все файлы `.java` в папке `src\main\java` командой:
```sh
$ javac *.java
```  
2. Для запуска сервера необходимо ввести в консоль команду:
```sh
$ java TFTPServerMain
``` 

При запуске сервера можно передать в качестве входных параметров хост и порт:


![Передача параметров при старте сервера](files\images\server custom.png)

Если этого не сделать, будут использоваться дефолтные значения:


![Дефолтные параметры при старте сервера](files\images\server default.png)

## Описание команд
Сервер поддерживает 1 команду:
- `/stop` - Выключение сервера

Клинет поддерживает команды согласно [спецификации TFTP](https://datatracker.ietf.org/doc/html/rfc1350)

## Протокол

TFTP - простой протокол для передачи фийлов. Релаизован поверх UDP, что позволяет передавать файлы между компьютерами, 
находящихся в разных сетях и реализующих UDP. Все, что может делать TFTP - читать или записывать файлы с/на удаленный сервер.

Так как TFTP основан поверх UDP, его пакеты имеют заголовок интернета, заголовок дейтаграммы и заголовок самого TFTP.
Порядок заголовков следующий:

![TFTP заголовки](files\images\TFTP headers.png)

Непосредственно сам TFTP протокол состоит из: 2-х байт Opcode, представляющих собой код операции. Всего существует 5 кодов
и в соответствии с ними пормируются следующие поля протокола. Коды можгут быть следующими:

- 1 - Read request (RRQ)
- 2 - Write request (WRQ)
- 3 - Data (DATA)
- 4 - Acknowledgment (ACK)
- 5 - Error (ERROR)

Расмотрим каждый из них

- 1 - Read request (RRQ) и 2 - Write request (WRQ)

   Данные запросы рассматриваются вместе, т.к. имеют одинаковые поля протокола и отличаются только своим Opcode
   
   Формат пакета:
   
   ![TFTP get/put](files\images\TFTP put get.png)
   
   После opcode следует имя файла, представленной в виде последовательности байтов в формате netascii, которое оканчивается символом 0b0 - нулевым байтом. 
   После следует поле mode - режим работы - то, как закодировано сообщение. Оно оканчивается так же нулевым байтом и может содержать в себе одно из следующих значений: 
   либо octet - показывающий, что передается файл в 8-разрядном формате, либо netascii - показывающий, что файл передаётся 
   без изменений, либо mail, подразумевающее, что строка получателя почты должна иметь вид "имя пользователя" или "username@hostname".

- 3 - Data (DATA)
   
   Формат пакета:
   
   ![TFTP data](files\images\TFTP Data.png)
   
   Код означает пакет данных. После двухбайтового поля opcode следует 2 байта для номера блока, после которого идет 512 байт передаваемых данных, 
   в случае если это только один из пакетов, либо от 1 до 511 байт в случае, если это последний пакет.
   
   Номера блоков в пакетах данных начинаются с 1 и увеличиваются на единицу для каждого нового блока данных. Это ограничение позволяет программе использовать
   один номер для того, чтобы разлить новые пакеты и дубликаты.
   
- 4 - Acknowledgment (ACK)
   
   Формат пакета:
   
   ![TFTP Ack](files\images\TFTP Ack.png)
   
   Код означает подтверждение пакета. Номер блока в ACK повторяет номер блока подтверждаемого пакета данных (DATA). 
   WRQ подтверждается пакетом ACK, имеющим номер блока, равный нулю.
   
- 5 - Error (ERROR)
   
   Формат пакета:
   
   ![TFTP Error](files\images\TFTP Error.png)  
   
   Код означет пакет с описанием ошибки. Может быть подтверждением любого другого типа пакета. Код ошибки представляет собой целое число, 
   указывающее на природу ошибки.  Сообщение об ошибке предназначено для использования человеком и должно быть в netascii. Как и все другие строки, он заканчивается
   нулевым байтом.
   
   Коды ошибок:
   - 0 - Not defined, see error message (if any).
   - 1 - File not found.
   - 2 - Access violation.
   - 3 - Disk full or allocation exceeded.
   - 4 - Illegal TFTP operation.
   - 5 - Unknown transfer ID.
   - 6 - File already exists.
   - 7 - No such user. 
   
### Принцип работы WRQ и RRQ:
#### RRQ:

В начальный момент времени сервер TFTP ожидает запросов от своих клиентов. Если одному из клиентов необходимо обратиться к файлам, находящимся на TFTP сервере, 
то он отправляют запрос RRQ к TFTP серверу. Если данный файл имеется на сервере и к нему можно получить доступ, то начинается 
процесс передачи и сервер отправляет клиенту первый блок, содержащий 512 байт данных (Если же запрошенный файл не доступен, то сервер генерирует сообщение об ошибки, передает его клиенту. 
На этом процесс передачи прекращается). Клиент получив блок данный с номером 1 генерирует подтверждение получение ACK данного блока, и так же дает ему номер 1. 
Получив данное подтверждение сервер начинает передачу следующего блока данных. (В случае, если подтверждение о получение 
блока данных не было получено до истечения таймаута, сервер осуществляет повторную передачу потерянного блока.) Данный 
процесс передачи происходит до тех пор пока все блоки данных, на которые был разбит файл, не будут переданы.

Визуализация этого процесса:

![TFTP RRQ](files\images\TFTP Read.png) 

#### WRQ:

В начальный момент времени сервер TFTP ожидает запросов от своих клиентов. Если одному из клиентов необходимо записать файл на TFTP сервер, то он отправляют запрос 
WRQ к TFTP серверу. Если сервер может осуществить запись данного файла, то он генерирует сообщение ACK с номером блока равным 0, и отправляет его запросившему клиенту, 
это сообщение означает согласие сервера на запись (Если сервер не может осуществить запись данного файла, то генерируется сообщение об ошибке, которое отправляется клиенту. 
На этом процесс записи завершается.). Клиент получив сообщение ACK с номером блока равным 0, начинает передачу первых 512 байт файла на сервер, пересылая их в сообщение DATA с 
номером блока 1. Если сервер получает данный блок, то он генерирует сообщение ACK с номером блока 1. Так происходит до тех пор пока сервер не получает блок данных размером менее 512 байт. 
В таком случае он подтверждает получение последнего блока данных и запись на этом завершается.

Визуализация этого процесса:

![TFTP WRQ](files\images\TFTP Write.png) 


## Реализация:

По дефолту сервер будет работать на порту 69 localhost-a. В классе ServerThread создаем сокет на известных host и port, после чего начинаем слушать входящие запросы.
При получении нового запроса сначала происходит определение того, какой именно это запрос. Для этого в классе TFTPProtocol происходит его обработка, получение opcode и уже на основе этого создается 
класс-наслденик от TFTPProtocol, соответствующий полученному opcode. Если полученный запрос является запросом на запись или чтение, то в классе ServerThread создается соответствующий 
запросу класс и в нем уже происходит вся последующая работа с ним, в соответствии с алгоритмом, описанным выше.

В качестве клиента использовался встроенный в Windows 10(7,8) TFTP-клиент

Файлы, переданные на сервер сохраняются в дерикторию проекта. Также из этой дериктории происходит загрудка файлов при get запросах

#### Пример работы сервера:

1. Запустим сервер и отправим с клиента файл. Файла не сервере изначально отсутствует:
    
    Клиент:
        ![TFTP client](files\images\TFTP first test client.png)         

    Сервер:
        ![TFTP server](files\images\TFTP first test server.png) 

    Как можно увидеть, файл мгновенно передался, о чем сообщилось и клиенту и серверу.
    
2. Попробуем получить файл с сервера. Файл на сервере присутствует:
    
    Клиент:
        ![TFTP client](files\images\TFTP second test client.png)     
        
    Сервер:
        ![TFTP server](files\images\TFTP second test server.png)
     
     Как можно увидеть, файл был получен с сервера.
     
3. Попробуем отправить на сервер файл. Файл на сервере изначально присутствует:

    Клиент:
        ![TFTP client](files\images\TFTP third test client.png)
        
    Сервер:
        ![TFTP server](files\images\TFTP third test server.png)
    
    Как можно увидеть, на сервере вывелась ошибка, что такой файл уже существует. Клиенту также выведась ошибка и файл не отправился
        
4. Пробуем получить с сервера файл. Файл на сервере отсутствует:

    Клиент:
        ![TFTP client](files\images\TFTP fourth test client.png)
        
    Сервер:
        ![TFTP server](files\images\TFTP fourth test server.png) 
        
    Как можно увидеть, на сервере вывелась ошибка, что такого файла не существует. Клиенту также выведась ошибка и файл не был получен

## Завершение работы

Завершение соединения может произойти со стороны сервера:

- Только при отправке в консоль сообщения `/stop`:

![Остановка сервера через /stop](files\images\TFTP stop.png)

## Источники:
- [Спецификация TFTP](https://datatracker.ietf.org/doc/html/rfc1350)
- [Опции TFTP](https://datatracker.ietf.org/doc/html/rfc2347)
- [Размер блока](https://datatracker.ietf.org/doc/html/rfc2348)